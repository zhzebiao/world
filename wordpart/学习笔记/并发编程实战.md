## 第二章 线程安全性

1. 对象的状态是指存储在状态变量（例如实例或静态域）中的数据。对象的状态可能包括其他依赖对象的域
2. 原子性：符合操作一定要满足原子性，否则会产生竞态条件
3. 使用锁能够实现同步

## 第三章 对象的共享

### 一、内存可见性

​	计算机的多级缓存设计会使线程修改无法及时反馈给其他线程

	- volatile变量会提供一种稍弱的同步机制，用来确保将变量的更新操作通知到其他线程

### 二、发布对象与对象逸出

	- 发布对象：使对象能够在当前作用域之外的代码中使用
	
	- 对象逸出：当某个不应该发布的对象被发布时，就称为逸出

避免发布对象的方法为线程封闭（避免共享，就无须同步）：

- Ad-hoc线程封闭
- 栈封闭
- ThreadLocal类对象

安全发布对象的方法有：

	- 在静态初始化函数中初始化一个对象引用
	- 将对象的引用保存到volatile类型的域或者AtomicReference对象中
	- 将对象的引用保存在某个正确构造对象的final类型域中
	- 将对象的引用保存到一个由锁保护的域中



## 第四章 对象的组合

### 一、设计线程安全的类

​	通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全的。一个线程安全类的设计过程中，需要包含以下三个基本要素：

- 找出构成对象状态的所有变量；
- 找出约束状态变量的不变性条件；
- 建立对象状态的并发访问管理策略。

### 二、线程安全的委托

- 委托给容器
- 委托给多个状态变量
- 多个状态变量存在关联，委托失效
- 如何安全发布底层的状态变量？取决于在类中对这些变量施加了哪些不变性条件。如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。

### 三、对现有线程安全类中添加功能

- 对线程安全类对象本身加锁。客户端不一定会遵守加锁规则。**（不推荐）**
- 采用组合方式对组合中方法进行加锁

## 第五章 基础构建模块

`本章将介绍Java平台类库中一些最有用的并发构建模块，以及使用这些模块来构建并发应用程序时的一些常用模式`

### 一、同步容器类

​	同步容器包括Vector和Hashtable，以及JDK中添加的一些功能相似的类。这些同步的封装器类是由Collections.synchronizedXXX等工厂方法创建的。

​	同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作`（常见的有：迭代和条件运算）`。在线程并发的时候，一条线程修改同步容器的长度会导致另一条线程迭代同步容器的时候发生ConcurrentModificationException异常。如果要规避这种问题只能在迭代的时候对容器加锁，或者对容器进行“克隆”。这些解决方法都会存在显著的性能开销。

### 二、并发容器

​	Java 5.0 提供了多钟并发容器来改进同步容器的性能。并发容器是针对多个线程并发访问设计的。

- ConcurrentHashMap：采用分段锁的加锁策略，使得任意数据的读取线程能够并发地访问Map，并允许一定数量的写入线程可以并发地修改Map。但反映Map总体状态方法的语义被略微减弱了，例如size和isEmpty，可能在返回时结果已经过期了。
- CopyOnWriteArrayList：线程安全性在于，只要正确地发布一个事实不变的对象，那么在访问该对象时就不再需要进一步的同步。显然，每当修改容器时都会复制底层数组，这需要一定的开销。仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器。

### 三、阻塞队列和生产者-消费者模式

- LinkedBlockingQueue和ArrayBlockingQueue：FIFO队列
- PriorityBlockingQueue：优先级排序的队列，实现Comparable方法。
- SynchronousQueue：同步队列，不会为队列中元素维护存储空间。当交付被接受时，就表明消费者已经得到了任务。仅当有足够多的消费者，并且总是有一个消费者准备好获取交付工作的时候，才适合使用同步队列
- Deque和BlockingDeque：双端队列

### 四、阻塞方法与中断方法

- 当某方法抛出InterruptedException时，表示该方法是一个阻塞方法。当在代码中调用了一个抛出InterruptedException异常的方法时，你自己的方法也就变成了一个阻塞方法，并且必须要处理对中断的响应。有两种基本选择：
  - 传递InterruptedException。
  - 恢复中断。
- 中断是一种协作机制。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作。

### 五、同步工具类

- 闭锁`（对零敏感，非零阻塞）`，可以延迟线程的进度直到其到达中止状态。当闭锁到达结束状态时，闭锁会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态。可以用来实现：
  - 资源初始化
  - 服务的依赖服务启动保障
  - 多玩家就绪状态保障。
- FutureTask。FutureTask表示的计算是通过Callable来实现的，相当于一种可生成结果的Runnable。值得注意的是，Callable表示任务可以抛出受检查的或未受检查的异常，并且任何代码都可能抛出一个Error。无论代码抛出什么异常，都会被封装到一个ExecutionException中，并在Future.get()中被重新抛出。
- 信号量。计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个特定操作的数量。计算信号量可以作为互斥体，具备不可重入的加锁语义。
- 栅栏。栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。CyclicBarrier可以使一定数量的参与方反复地在栅栏位置汇聚，在并行迭代算法中非常有用。

### 六、构建高效且可伸缩的结果缓存

```java
// 基于FutureTask的Memorizing封装器
class Memorizer3<A, V> implements Computable<A, V> {
    private final Map<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>();
    private final Computable<A, V> c;

    public Memorizer3(Computable<A, V> c) {
        this.c = c;
    }

    @Override
    public V compute(final A arg) throws InterruptedException {
        Future<V> f = cache.get(arg);
        if (f == null) {
            Callable<V> eval = new Callable<V>() {
                @Override
                public V call() throws Exception {
                    return c.compute(arg);
                }
            };
            FutureTask<V> ft = new FutureTask<V>(eval);
            f = cache.putIfAbsent(arg,ft);
            if(f ==null) {
                f = ft;
                ft.run();
            }
        }
        try {
            return f.get();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        return null;
    }
}

interface Computable<A, V> {
    V compute(A arg) throws InterruptedException;
}
```



## 第六章 任务执行

### 一、在线程中执行任务

​	当围绕“任务执行”来设计应用程序结构时，第一步就是要找出清晰的任务边界。在理想情况下，各个任务之间是相互独立的：任务并不依赖于其他任务的状态、结果或边界效应。

​	在正常的负载下，服务器应用程序应该同时表现出良好的吞吐量和快速的响应性。但是串行处理机制通常无法提供高吞吐率或快速响应性。

​	**显示的为任务创建线程**：

​	与串行处理机制不同的有：

 - 任务处理过程从主线程中分离出来，使得主循环能够更快的重新等待下一个到来的连接。这使得程序在完成前面的请求之前可以接受新的请求，从而提高响应性。
 - 任务可以并行处理，从而能同时服务多个请求。
 - 任务处理代码必须是线程安全的。

​    无线创建线程的不足：

- 线程生命周期的开销非常高；
- 资源消耗问题；
- 稳定性问题。

### 二、Executor框架

​	任务是一组逻辑工作单元，线程是使任务异步执行的机制。线程池简化了线程的管理工作，并且java.util.concurrent提供了一种灵活的线程池实现作为Executor框架的一部分。在Java类库中，任务执行的主要抽象不是Thread，而是Executor。

> ​	通过将任务的提交和执行解耦开来，从而无需太大的困难就可以为某种类型的任务指定和修改执行策略。在执行策略中定义了任务执行的"What、Where、When、How"等方面，包括：
>
> - 在什么线程中执行任务？
> - 任务按照什么顺序执行（FIFO,LIFO,优先级）？
> - 有多少个任务能并发执行？（running task）
> - 在队列中有多少个任务在等待执行？（queueing task）
> - 如果系统由于过载而需要拒绝一个任务，那么应该选择哪一个任务？另外，如何通知应用程序有任务被拒绝？
> - 在执行一个任务之前或之后，应该进行哪些动作？

### 三、Executor的生命周期

- ExecutorService：管理Executor的生命周期。

```shell
# 执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成
void shutdown();
# 执行粗暴的关闭过程：将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务
List<Runnable> shutdownNow();
boolean isShutdown();
# 轮询ExecutorService是否已经终止
boolean isTerminated();
# 等待ExecutorService到达终止状态
boolean awaitTermination(long timeout,TimeUnit unit) throws InterruptedExeception;
```


## 第四章 对象的组合

### 一、设计线程安全的类

​	通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全的。一个线程安全类的设计过程中，需要包含以下三个基本要素：

- 找出构成对象状态的所有变量；
- 找出约束状态变量的不变性条件；
- 建立对象状态的并发访问管理策略。

### 二、线程安全的委托

- 委托给容器
- 委托给多个状态变量
- 多个状态变量存在关联，委托失效
- 如何安全发布底层的状态变量

### 三、对现有线程安全类中添加功能

- 对线程安全类对象本身加锁。客户端不一定会遵守加锁规则。
- 采用组合方式对组合中方法进行加锁

## 第五章 基础构建模块

`本章将介绍Java平台类库中一些最有用的并发构建模块，以及使用这些模块来构建并发应用程序时的一些常用模式`

### 一、同步容器类

​	同步容器包括Vector和Hashtable，以及JDK中添加的一些功能相似的类。这些同步的封装器类是由Collections.synchronizedXXX等工厂方法创建的。

​	同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作`（常见的有：迭代和条件运算）`。在线程并发的时候，一条线程修改同步容器的长度会导致另一条线程迭代同步容器的时候发生ConcurrentModificationException异常。如果要规避这种问题只能在迭代的时候对容器加锁，或者对容器进行“克隆”。这些解决方法都会存在显著的性能开销。

### 二、并发容器

​	Java 5.0 提供了多钟并发容器来改进同步容器的性能。并发容器是针对多个线程并发访问设计的。

- ConcurrentHashMap：采用分段锁的加锁策略，使得任意数据的读取线程能够并发地访问Map，并允许一定数量的写入线程可以并发地修改Map。但反映Map总体状态方法的语义被略微减弱了，例如size和isEmpty，可能在返回时结果已经过期了。
- CopyOnWriteArrayList：线程安全性在于，只要正确地发布一个事实不变的对象，那么在访问该对象时就不再需要进一步的同步。显然，每当修改容器时都会复制底层数组，这需要一定的开销。仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器。

### 三、阻塞队列和生产者-消费者模式

- LinkedBlockingQueue和ArrayBlockingQueue：FIFO队列
- PriorityBlockingQueue：优先级排序的队列，实现Comparable方法。
- SynchronousQueue：同步队列，不会为队列中元素维护存储空间。当交付被接受时，就表明消费者已经得到了任务。仅当有足够多的消费者，并且总是有一个消费者准备好获取交付工作的时候，才适合使用同步队列
- Deque和BlockingDeque：双端队列


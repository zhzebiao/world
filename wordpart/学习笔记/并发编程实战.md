## 第四章 对象的组合

### 一、设计线程安全的类

​	通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全的。一个线程安全类的设计过程中，需要包含以下三个基本要素：

- 找出构成对象状态的所有变量；
- 找出约束状态变量的不变性条件；
- 建立对象状态的并发访问管理策略。

### 二、线程安全的委托

- 委托给容器
- 委托给多个状态变量
- 多个状态变量存在关联，委托失效
- 如何安全发布底层的状态变量

### 三、对现有线程安全类中添加功能

- 对线程安全类对象本身加锁。客户端不一定会遵守加锁规则。
- 采用组合方式对组合中方法进行加锁

## 第五章 基础构建模块

`本章将介绍Java平台类库中一些最有用的并发构建模块，以及使用这些模块来构建并发应用程序时的一些常用模式`

### 一、同步容器类

​	同步容器包括Vector和Hashtable，以及JDK中添加的一些功能相似的类。这些同步的封装器类是由Collections.synchronizedXXX等工厂方法创建的。

​	同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作`（常见的有：迭代和条件运算）`。在线程并发的时候，一条线程修改同步容器的长度会导致另一条线程迭代同步容器的时候发生ConcurrentModificationException异常。如果要规避这种问题只能在迭代的时候对容器加锁，或者对容器进行“克隆”。这些解决方法都会存在显著的性能开销。

### 二、并发容器

​	Java 5.0 提供了多钟并发容器来改进同步容器的性能。并发容器是针对多个线程并发访问设计的。

- ConcurrentHashMap：采用分段锁的加锁策略，使得任意数据的读取线程能够并发地访问Map，并允许一定数量的写入线程可以并发地修改Map。但反映Map总体状态方法的语义被略微减弱了，例如size和isEmpty，可能在返回时结果已经过期了。
- CopyOnWriteArrayList：线程安全性在于，只要正确地发布一个事实不变的对象，那么在访问该对象时就不再需要进一步的同步。显然，每当修改容器时都会复制底层数组，这需要一定的开销。仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器。

### 三、阻塞队列和生产者-消费者模式

- LinkedBlockingQueue和ArrayBlockingQueue：FIFO队列
- PriorityBlockingQueue：优先级排序的队列，实现Comparable方法。
- SynchronousQueue：同步队列，不会为队列中元素维护存储空间。当交付被接受时，就表明消费者已经得到了任务。仅当有足够多的消费者，并且总是有一个消费者准备好获取交付工作的时候，才适合使用同步队列
- Deque和BlockingDeque：双端队列

### 四、阻塞方法与中断方法

- 当某方法抛出InterruptedException时，表示该方法是一个阻塞方法。当在代码中调用了一个抛出InterruptedException异常的方法时，你自己的方法也就变成了一个阻塞方法，并且必须要处理对中断的响应。有两种基本选择：
  - 传递InterruptedException。
  - 恢复中断。
- 中断是一种协作机制。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作。

### 五、同步工具类

- 闭锁，可以延迟线程的进度直到其到达中止状态。当闭锁到达结束状态时，闭锁会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态。可以用来实现：
  - 资源初始化
  - 服务的依赖服务启动保障
  - 多玩家就绪状态保障。
- FutureTask。FutureTask表示的计算是通过Callable来实现的，相当于一种可生成结果的Runnable。值得注意的是，Callable表示任务可以抛出受检查的或未受检查的异常，并且任何代码都可能抛出一个Error。无论代码抛出什么异常，都会被封装到一个ExecutionException中，并在Future.get()中被重新抛出。
- 信号量。计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个特定操作的数量。计算信号量可以作为互斥体，具备不可重入的加锁语义。
- 栅栏。栅栏类似于闭锁，它能阻塞一组线程知道某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。CyclicBarrier可以使一定数量的参与方反复地在栅栏位置汇聚，在并行迭代算法中非常有用。

### 六、构建高效且可伸缩的结果缓存

```java
// 基于FutureTask的Memorizing封装器
class Memorizer3<A, V> implements Computable<A, V> {
    private final Map<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>();
    private final Computable<A, V> c;

    public Memorizer3(Computable<A, V> c) {
        this.c = c;
    }

    @Override
    public V compute(final A arg) throws InterruptedException {
        Future<V> f = cache.get(arg);
        if (f == null) {
            Callable<V> eval = new Callable<V>() {
                @Override
                public V call() throws Exception {
                    return c.compute(arg);
                }
            };
            FutureTask<V> ft = new FutureTask<V>(eval);
            f = cache.putIfAbsent(arg,ft);
            if(f ==null) {
                f = ft;
                ft.run();
            }
        }
        try {
            return f.get();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        return null;
    }
}

interface Computable<A, V> {
    V compute(A arg) throws InterruptedException;
}
```



## 第六章 任务执行

### 一、Executor框架

​	任务是一组逻辑工作单元，线程是使任务异步执行的机制。线程池简化了线程的管理工作，并且java.util.concurrent提供了一种灵活的线程池实现作为Executor框架的一部分。在Java类库中，任务执行的主要抽象不是Thread，而是Executor。

> ​	通过将任务的提交和执行解耦开来，从而无需太大的困难就可以为某种类型的任务指定和修改执行策略。在执行策略中定义了任务执行的"What、Where、When、How"等方面，包括：
>
> - 在什么线程中执行任务？
> - 任务按照什么顺序执行（FIFO,LIFO,优先级）？
> - 有多少个任务能并发执行？（running task）
> - 在队列中有多少个任务在等待执行？（queueing task）
> - 如果系统由于过载而需要拒绝一个任务，那么应该选择哪一个任务？另外，如何通知应用程序有任务被拒绝？
> - 在执行一个任务之前或之后，应该进行哪些动作？

- ExecutorService：管理Executor的生命周期。

```shell
# 执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成
void shutdown();
# 执行粗暴的关闭过程：将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务
List<Runnable> shutdownNow();
boolean isShutdown();
# 轮询ExecutorService是否已经终止
boolean isTerminated();
# 等待ExecutorService到达终止状态
boolean awaitTermination(long timeout,TimeUnit unit) throws InterruptedExeception;
```

